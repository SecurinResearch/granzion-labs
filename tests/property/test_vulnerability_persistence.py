"""
Property-based tests for intentional vulnerability persistence.

Tests Property 17 from the design document.
"""

import pytest
from hypothesis import given, strategies as st, settings
import re
from pathlib import Path
from typing import Dict, List, Set

# Known intentional vulnerabilities that must persist
REQUIRED_VULNERABILITIES = {
    # Identity & Trust
    "IT-01", "IT-02", "IT-03", "IT-04", "IT-05", "IT-06",
    # Memory
    "M-01", "M-02", "M-03", "M-04", "M-05", "M-06",
    # Tool
    "T-01", "T-02", "T-03", "T-04", "T-05",
    # Communication
    "C-01", "C-02", "C-03", "C-04", "C-05",
    # Orchestration
    "O-01", "O-02", "O-03", "O-04",
    # Autonomy
    "A-01", "A-02", "A-03", "A-04",
    # Infrastructure
    "IF-01", "IF-02", "IF-03", "IF-04", "IF-05",
    # Visibility
    "V-01", "V-02", "V-03", "V-04", "V-05",
}


def find_vulnerability_markers(root_dir: Path) -> Dict[str, List[str]]:
    """Find all vulnerability markers in code."""
    markers = {}
    
    # Search in src/ and scenarios/
    for pattern in ["src/**/*.py", "scenarios/**/*.py"]:
        for file_path in root_dir.glob(pattern):
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Find all VULNERABILITY comments
                matches = re.findall(
                    r'#\s*VULNERABILITY:?\s*([A-Z]{1,2}-\d{2}(?:,\s*[A-Z]{1,2}-\d{2})*)',
                    content,
                    re.IGNORECASE
                )
                
                for match in matches:
                    # Split multiple threat IDs
                    threat_ids = [tid.strip() for tid in match.split(',')]
                    for threat_id in threat_ids:
                        if threat_id not in markers:
                            markers[threat_id] = []
                        markers[threat_id].append(str(file_path.relative_to(root_dir)))
            except Exception:
                continue
    
    return markers


def check_vulnerability_in_file(file_path: Path, vulnerability_pattern: str) -> bool:
    """Check if a vulnerability pattern exists in a file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        return vulnerability_pattern in content
    except Exception:
        return False


# ============================================================================
# Property 17: Intentional Vulnerability Persistence
# ============================================================================
# **Validates: Requirements 13.5**
#
# All intentional vulnerabilities must persist in the codebase and be
# properly documented with threat ID markers.

@pytest.mark.property
@settings(max_examples=1)  # Run once - this is a static analysis test
def test_property_17_vulnerability_persistence():
    """
    Property 17: Intentional vulnerabilities must persist.
    
    This property validates that:
    1. All required vulnerabilities are present in code
    2. Each vulnerability has proper # VULNERABILITY: markers
    3. Vulnerability markers reference correct threat IDs
    4. No vulnerabilities have been accidentally fixed
    5. Vulnerability catalog is complete
    """
    root_dir = Path(__file__).parent.parent.parent
    
    # Find all vulnerability markers in code
    code_markers = find_vulnerability_markers(root_dir)
    
    # Property assertion 1: All required vulnerabilities are present
    found_vulnerabilities = set(code_markers.keys())
    missing_vulnerabilities = REQUIRED_VULNERABILITIES - found_vulnerabilities
    
    assert not missing_vulnerabilities, \
        f"Missing required vulnerabilities: {sorted(missing_vulnerabilities)}"
    
    # Property assertion 2: Each vulnerability has code markers
    for vuln_id in REQUIRED_VULNERABILITIES:
        assert vuln_id in code_markers, \
            f"Vulnerability {vuln_id} has no code markers"
        
        assert len(code_markers[vuln_id]) > 0, \
            f"Vulnerability {vuln_id} has no associated files"
    
    # Property assertion 3: Vulnerability markers are properly formatted
    for vuln_id, files in code_markers.items():
        # Check format: XX-NN where XX is 1-2 letters, NN is 2 digits
        assert re.match(r'^[A-Z]{1,2}-\d{2}$', vuln_id), \
            f"Invalid vulnerability ID format: {vuln_id}"
    
    # Property assertion 4: Critical vulnerabilities are present
    critical_vulnerabilities = {
        "IT-02",  # Impersonate without validation
        "T-02",   # SQL injection
        "IF-02",  # Command injection
        "C-02",   # Message forgery
        "M-02",   # Similarity boost manipulation
    }
    
    for vuln_id in critical_vulnerabilities:
        assert vuln_id in found_vulnerabilities, \
            f"Critical vulnerability {vuln_id} is missing!"
    
    # Property assertion 5: Vulnerability catalog exists
    catalog_path = root_dir / "docs" / "VULNERABILITIES.md"
    assert catalog_path.exists(), \
        "Vulnerability catalog (VULNERABILITIES.md) not found"
    
    # Property assertion 6: Catalog documents all vulnerabilities
    with open(catalog_path, 'r', encoding='utf-8') as f:
        catalog_content = f.read()
    
    for vuln_id in REQUIRED_VULNERABILITIES:
        assert vuln_id in catalog_content, \
            f"Vulnerability {vuln_id} not documented in catalog"


@pytest.mark.property
@settings(max_examples=1)
def test_property_17_vulnerability_distribution():
    """
    Property 17 (Distribution): Vulnerabilities cover all threat categories.
    
    This property validates that:
    1. Each threat category has vulnerabilities
    2. Vulnerabilities are distributed across components
    3. No category is under-represented
    """
    root_dir = Path(__file__).parent.parent.parent
    code_markers = find_vulnerability_markers(root_dir)
    found_vulnerabilities = set(code_markers.keys())
    
    # Define expected categories
    categories = {
        "IT": "Identity & Trust",
        "M": "Memory",
        "T": "Tool",
        "C": "Communication",
        "O": "Orchestration",
        "A": "Autonomy",
        "IF": "Infrastructure",
        "V": "Visibility",
    }
    
    # Property assertion 1: Each category has vulnerabilities
    for prefix, name in categories.items():
        category_vulns = [v for v in found_vulnerabilities if v.startswith(prefix)]
        assert len(category_vulns) > 0, \
            f"No vulnerabilities found for category {name} ({prefix})"
    
    # Property assertion 2: Each category has at least 3 vulnerabilities
    for prefix, name in categories.items():
        category_vulns = [v for v in found_vulnerabilities if v.startswith(prefix)]
        assert len(category_vulns) >= 3, \
            f"Category {name} ({prefix}) has only {len(category_vulns)} vulnerabilities (expected >= 3)"
    
    # Property assertion 3: Vulnerabilities are in multiple files
    for vuln_id in REQUIRED_VULNERABILITIES:
        if vuln_id in code_markers:
            files = code_markers[vuln_id]
            # Some vulnerabilities may be in multiple files (exploited in scenarios)
            assert len(files) >= 1, \
                f"Vulnerability {vuln_id} not found in any files"


@pytest.mark.property
@settings(max_examples=1)
def test_property_17_mcp_vulnerabilities():
    """
    Property 17 (MCP): Each MCP server has intentional vulnerabilities.
    
    This property validates that:
    1. Each MCP server has vulnerability markers
    2. MCPs have appropriate vulnerability types
    3. Critical MCPs have critical vulnerabilities
    """
    root_dir = Path(__file__).parent.parent.parent
    code_markers = find_vulnerability_markers(root_dir)
    
    # Define MCP servers and expected vulnerability types
    mcp_servers = {
        "identity_mcp.py": ["IT"],
        "memory_mcp.py": ["M"],
        "data_mcp.py": ["T"],
        "comms_mcp.py": ["C"],
        "infra_mcp.py": ["IF"],
    }
    
    # Property assertion 1: Each MCP has vulnerabilities
    for mcp_file, expected_prefixes in mcp_servers.items():
        mcp_path = root_dir / "src" / "mcps" / mcp_file
        
        # Find vulnerabilities in this MCP
        mcp_vulns = [
            vuln_id for vuln_id, files in code_markers.items()
            if any(mcp_file in f for f in files)
        ]
        
        assert len(mcp_vulns) > 0, \
            f"MCP {mcp_file} has no vulnerabilities"
        
        # Property assertion 2: MCP has appropriate vulnerability types
        mcp_prefixes = set(v.split('-')[0] for v in mcp_vulns)
        expected_set = set(expected_prefixes)
        
        assert mcp_prefixes & expected_set, \
            f"MCP {mcp_file} missing expected vulnerability types {expected_prefixes}"


@pytest.mark.property
@settings(max_examples=1)
def test_property_17_agent_vulnerabilities():
    """
    Property 17 (Agents): Each agent has intentional vulnerabilities.
    
    This property validates that:
    1. Each agent has documented vulnerabilities
    2. Agents have appropriate vulnerability types
    3. Agent instructions document vulnerabilities
    """
    root_dir = Path(__file__).parent.parent.parent
    
    # Define agents and expected characteristics
    agents = {
        "orchestrator.py": ["O", "C"],  # Orchestration and Communication
        "researcher.py": ["M"],          # Memory
        "executor.py": ["A", "T"],       # Autonomy and Tool
        "monitor.py": ["V"],             # Visibility
    }
    
    # Property assertion 1: Each agent file exists
    for agent_file in agents.keys():
        agent_path = root_dir / "src" / "agents" / agent_file
        assert agent_path.exists(), \
            f"Agent file {agent_file} not found"
    
    # Property assertion 2: Each agent has vulnerability documentation
    for agent_file, expected_types in agents.items():
        agent_path = root_dir / "src" / "agents" / agent_file
        
        with open(agent_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Check for vulnerability documentation in instructions
        assert "VULNERABILITY" in content or "vulnerability" in content, \
            f"Agent {agent_file} has no vulnerability documentation"


@pytest.mark.property
@settings(max_examples=1)
def test_property_17_scenario_exploitation():
    """
    Property 17 (Scenarios): Scenarios exploit documented vulnerabilities.
    
    This property validates that:
    1. Each scenario exploits specific vulnerabilities
    2. Scenario vulnerability markers match catalog
    3. All vulnerabilities are exploited by at least one scenario
    """
    root_dir = Path(__file__).parent.parent.parent
    code_markers = find_vulnerability_markers(root_dir)
    
    # Find vulnerabilities exploited in scenarios
    scenario_vulns = set()
    for vuln_id, files in code_markers.items():
        if any("scenarios/" in f for f in files):
            scenario_vulns.add(vuln_id)
    
    # Property assertion 1: Most vulnerabilities are exploited in scenarios
    # (Some may only be in MCP/agent code)
    exploitation_rate = len(scenario_vulns) / len(REQUIRED_VULNERABILITIES)
    assert exploitation_rate >= 0.7, \
        f"Only {exploitation_rate:.1%} of vulnerabilities exploited in scenarios (expected >= 70%)"
    
    # Property assertion 2: Critical vulnerabilities are exploited
    critical_vulnerabilities = {"IT-02", "T-02", "IF-02", "C-02", "M-02"}
    for vuln_id in critical_vulnerabilities:
        assert vuln_id in scenario_vulns, \
            f"Critical vulnerability {vuln_id} not exploited in any scenario"


# ============================================================================
# Additional Validation Tests
# ============================================================================

def test_vulnerability_catalog_exists():
    """Test that vulnerability catalog exists and is complete."""
    root_dir = Path(__file__).parent.parent.parent
    catalog_path = root_dir / "docs" / "VULNERABILITIES.md"
    
    assert catalog_path.exists(), "VULNERABILITIES.md not found"
    
    with open(catalog_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Check for required sections
    assert "# Intentional Vulnerabilities Catalog" in content
    assert "Identity & Trust Vulnerabilities" in content
    assert "Memory Vulnerabilities" in content
    assert "Tool Vulnerabilities" in content
    assert "Communication Vulnerabilities" in content
    assert "Orchestration Vulnerabilities" in content
    assert "Autonomy Vulnerabilities" in content
    assert "Infrastructure Vulnerabilities" in content
    assert "Visibility Vulnerabilities" in content


def test_vulnerability_markers_format():
    """Test that vulnerability markers follow correct format."""
    root_dir = Path(__file__).parent.parent.parent
    code_markers = find_vulnerability_markers(root_dir)
    
    for vuln_id in code_markers.keys():
        # Format: XX-NN where XX is 1-2 uppercase letters, NN is 2 digits
        assert re.match(r'^[A-Z]{1,2}-\d{2}$', vuln_id), \
            f"Invalid vulnerability ID format: {vuln_id}"


def test_no_accidental_fixes():
    """Test that vulnerabilities haven't been accidentally fixed."""
    root_dir = Path(__file__).parent.parent.parent
    
    # Check specific critical vulnerabilities
    critical_checks = [
        ("src/mcps/identity_mcp.py", "impersonate", "IT-02"),
        ("src/mcps/data_mcp.py", "execute_sql", "T-02"),
        ("src/mcps/infra_mcp.py", "execute_command", "IF-02"),
        ("src/mcps/comms_mcp.py", "forge_message", "C-02"),
        ("src/mcps/memory_mcp.py", "inject_memory", "M-02"),
    ]
    
    for file_path, function_name, vuln_id in critical_checks:
        full_path = root_dir / file_path
        assert full_path.exists(), f"File {file_path} not found"
        
        with open(full_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        assert function_name in content, \
            f"Critical function {function_name} not found in {file_path} (vulnerability {vuln_id} may be fixed)"
